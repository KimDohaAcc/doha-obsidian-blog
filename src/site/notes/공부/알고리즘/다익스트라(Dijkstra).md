---
{"dg-publish":true,"permalink":"/공부/알고리즘/다익스트라(Dijkstra)/","dgPassFrontmatter":true}
---

음의 가중치가 없는 그래프의 한 정점에서 모든 정점까지의 **최단 거리**를 각각 구하는 알고리즘(최단 경로 문제, Shortest Path Problem)으로 **그리디** 알고리즘에 속한다.

다익스트라는 변형이 많다. 원래 알고리즘은 **두 꼭짓점 간의 가장 짧은 경로를 찾는** 알고리즘이지만, 더 일반적인 변형은 한 꼭짓점을 **소스 꼭짓점**으로 고정하고 그래프의 다른 모든 꼭짓점까지의 최단 경로를 찾는 알고리즘으로 **최단 경로 트리**를 만드는 것이다.

모든 정점에서 다른 모든 정점은 아닌것에 주의, 이걸 원한다면 [[공부/알고리즘/플로이드 워셜 알고리즘(Floyd-Warshall Algorithm)\|플로이드 워셜 알고리즘(Floyd-Warshall Algorithm)]]을 써야한다

#### 알고리즘의 바탕이 되는 논리

> [!note] 
> *R이 P에서 Q로 가는 최단 경로에 있는 꼭짓점이라면, 이 경로는 마찬가지로 P에서 R까지 가는 최단 경로*라는 사실을 이용한다

벨먼의 유명한 최적성의 원리를 최단 경로 문제의 맥락에서 해석한 것이다.

#### 시간복잡도
**O((V+E)logV)**(V는 정점의 개수, E는 한 정점의 주변 노드)
➡ 각 노드마다 미방문 노드 중 출발점으로부터 현재까지 계산된 최단 거리를 가지는 ==노드를 찾는데== O(VlogV)의 시간이 필요하고 각 노드마다 ==이웃한 노드의 최단 거리를 갱신==할 때 O(ElogV)의 시간이 필요하기 때문이다

#### 그래프 방향
무향, 유향 상관 없으나 간선 중 하나라도 가중치가 음수면 사용할 수 없다.
음수인 경우[[벨만-포드 알고리즘\|벨만-포드 알고리즘]]을 사용 가능하다.

#### 실제 이용
큐브, 내비게이션(도시:노드, 도로:간선), 미로 탐색, 라우팅 OSPF

#### 구현
1. 출발점으로부터 **최단거리를 저장할 배열 d[v]** 를 만든다.
2. **출발 노드에는 0**을, 다른 노드에는 **INF**(최대값)를 채워넣는다.
3. **방문 배열을 생성**하여 방문했던 노드는 재방문하지 않게 한다.[[공부/알고리즘/다익스트라(Dijkstra)#^visited\|#^visited]]
4. 출발 노드의 번호를 **변수([[공부/SW/자료구조/Priority Queue\|Priority Queue]])** 에 저장한다.
5. 미방문 상태인 출발 노드에서 `d[A] + P[A][B]` 와 `d[B]`의 값을 비교한다.(P는 가중치 배열)
6. 전자가 짧다면 `d[B]` 의 값을 전자로 **갱신**시킨다.
7. A에 이웃한 모든 노드에 대해 작업을 수행한 후, A의 상태를 **방문 완료**로 바꾼다.
8. **미방문 상태**인 모든 노드들 중 출발점으로부터 거리가 가장 짧은 노드를 골라(Priority Queue를 썼다면 해당 과정이 필요 없다) **변수에 저장**한다.
9. 도착 노드가 방문 완료 상태가 되거나, 혹은 더 이상 미방문 상태의 노드가 없을 때까지 과정을 **반복**한다.
10. 작업을 마친 뒤 생성된 `d[x]`가 의미하는 바는 **시작점으로부터 노드 x까지의 최단 거리**이다.


#### Priority Queue 구현 시 정렬
단순 Integer, int[] 로 구현
````java

// 1)
PriorityQueue<Integer> maxHeap = new PriorityQueue<(Collections.reverseOrder());

// 2)
PriorityQueue<Integer> queue = new PriorityQueue<>((o1, o2) -> {
	int abs1 = Math.abs(o1);
	int abs2 = Math.abs(o2);

	if(abs1 == abs2) return o1 > o2 ? 1 : -1;
	return abs1 - abs2;
});

````

class로 구현할 때는 Combarable을 implements 받아서 구현














### 각주

#### 방문처리{ #visited}


다시 탐색할 필요가 없기 떄문에 방문처리를 하여 똑같은 탐색을 하지 않게 한다.
1)  거리순으로 정렬을 해놓고 **거리가 짧은 순으로 방문**을 하는데,
2)  이는 그리디한 방식이지만 검증이 끝나서 **최솟값이 보장**되어 있다.
3)  따라서 한 번 방문했던 노드를 재방문할 필요가 없다!