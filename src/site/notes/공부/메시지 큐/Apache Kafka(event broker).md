---
{"dg-publish":true,"permalink":"/공부/메시지 큐/Apache Kafka(event broker)/","dgPassFrontmatter":true}
---


![kafka_image.jpg](/img/user/첨부파일/kafka_image.jpg)

카프카는 메시지 큐의 역할을 할 수 있는 event broker이다. 이벤트 브로커는 이벤트 프로듀서(Event Producer)로부터 이벤트를 수집하고, 이를 이벤트 컨슈머(Event Consumer)에게 전달하는 미들웨어 역할을 한다.

### 왜 Event Broker?

메시지(Message)
- **"~해라"라는 명령이나 지시의 성격**
- 특정 수신자를 목적으로 전송
- 수신자가 메시지를 처리하면 일반적으로 삭제됨

이벤트(Event)
- **"~가 발생했다"는 사실의 기록**
- 발생한 사실에 관심있는 여러 시스템이 구독 가능
- 불변하며 과거에 발생한 사실

Kafka는 일반 메시지 큐가 메시지를 전달 후 즉시 삭제하는 것에 반해, 보관 기간 동안 이벤트를 저장하고, 이를 재처리할 수 있다

### 특징

**메시지 순서 보장이 된다(채팅 기능에 가장 적합)**

==높은 처리량과 낮은 지연시간==으로 대용량 데이터를 실시간으로 처리할 수 있다

카프카의 메시지는 메모리가 아닌 ==디스크에 영구적으로 저장==되기 때문에 장애 발생 시에도 메시지가 유실되지 않는다

카프카 클러스터 내부에 여러 대의 브로커 서버를 구성하여 ==높은 확장성과 내결함성==을 갖는다

RabbitMQ와 ActiveMQ는 브로커가 컨슈머로 메시지를 Push 하는 방식인데 반해, 카프카는 컨슈머가 능동적으로 브로커로부터 메시지를 가져오는 ==Pull== 방식이다

이러한 이유 때문에 [[공부/웹소켓/STOMP(Simple Text Oriented Messaging Protocol)\|STOMP(Simple Text Oriented Messaging Protocol)]] 단일로 메세지를 전송하는 것보다 카프카를 메세지큐로 사용하는 것이 안정적이고 확장성이 좋은 방법이다

### 용어

- **카프카 클러스터 (kafka cluster)**: 하나 이상의 카프카 브로커들의 집합
- **브로커 (broker)**: 개별 카프카 서버. 브로커는 프로듀서로부터 메시지를 전달받아 토픽에 저장하고,컨슈머에 전달하는 역할을 한다. 브로커는 여러개의 토픽을 가질 수 있다.
- **토픽 (topic)**: 데이터가 저장되는 단위.
- **파티션 (partition)**: 확장성을 위해 토픽은 1개 이상의 파티션으로 나뉠 수 있다. 레코드에 키가 없다면 라운드 로빈으로 파티션에 나뉘어 저장되고, 같은 키를 가진 레코드는 같은 파티션에 저장된다.
- **오프셋 (offset)**: 파티션에 저장된 레코드는 증가하는 정수 ID를 갖고, 이를 오프셋이라고 부른다.
- **레코드 (record)**: 파티션에 저장되는 데이터
- **프로듀서 (producer)**: 카프카에 요청하여 토픽에 레코드를 추가하는 클라이언트. 카프카에 요청하는 애플리케이션이다.
- **컨슈머 (consumer)**: 하나 이상의 파티션과 토픽으로부터 ==레코드를 읽어오는 클라이언트==. 
- **컨슈머 그룹 (consumer group)**: 동일한 컨슈머 인스턴스를 여러개 생성하여 컨슈머 그룹을 구성할 수 있다. 