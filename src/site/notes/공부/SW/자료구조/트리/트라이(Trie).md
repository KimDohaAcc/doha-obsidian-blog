---
{"dg-publish":true,"permalink":"/공부/SW/자료구조/트리/트라이(Trie)/","dgPassFrontmatter":true}
---

![Pasted image 20240302172247.png](/img/user/%EC%B2%A8%EB%B6%80%ED%8C%8C%EC%9D%BC/Pasted%20image%2020240302172247.png)
문자를 저장하고 효율적으로 탐색하기 위한 [[공부/SW/자료구조/트리/트리(Tree)\|트리(Tree)]] 형태의 자료구조

위의 예시는 문자열 집합 **{"rebro", "replay", "hi" , "high", "algo"}** 를 트라이로 구현한 것이다. **빨간색으로 나타낸 노드는 문자열의 끝**을 의미한다

자동완성 기능, 사전 검색 등 문자열을 탐색하는 데 특화되어있다

자연어 처리 분야에서 문자열 탐색을 위한 자료구조로 쓰이고 있으며, 검색을 뜻하는 Re==trie==val의 중간 음절을 따와 Trie라고 부른다

#### 특징
루트 노드는 특정 문자를 의미하지 않고, **자식 노드만 가지고 있다**(=루트 노드는 빈 문자와 연관)
자식 노드는 Map<Key, Value> 형태로 가지고 있다
루트 노드를 제외한 노드의 자손들은 해당 노드와 공통 접두어를 가지고 있다
#### 장점
[[공부/SW/자료구조/트리/힙(Heap)\|힙(Heap)]]과 같은 자료구조에서 원소를 찾는 데는 O(logN)의 시간이 걸린다
이를 문자열에 적용하면 문자열을 비교하기 위해서는 **문자열의 길이만큼** 시간이 걸리기 때문에 원하는 문자열을 찾기 위해서는 ==O(MlogN)==의 시간이 소요된다(M:문자열 길이, N: 문자열 개수)

이러한 문제를 해결하기 위한 문자열 특화 자료구조가 트라이이다

트라이에서 문자열을 탐색할 때는 다음 글자에 해당하는 노드가 연결되어 있는지를 확인하며, 문자열의 끝에 도달했을 때 해당 노드에서 끝나는 문자열(빨간 노드)이 있다면 찾고자 하는 문자열이 집합에 포함되어 있는 것이다

이러한 구조 때문에 문자열의 길이만큼인 O(M)만에 탐색이 가능하며, 문자열 추가도 마찬가지의 시간이 걸린다

#### 단점
트라이의 단점은 **필요한 메모리의 크기가 너무 크다**는 점이다
트라이에 필요한 총메모리는 O(포인터 크기 * 포인터 배열 개수 * 총 노드의 개수)가 된다
그렇기에 1000자리 문자열이 1000개만 들어온다고 하더라도 100만 개의 노드가 필요하고, 포인터의 크기가 8byte라고 하면 약 200MB의 메모리가 필요하게 된다

따라서 이 단점을 해결하기 위해 map이나 vector를 이용해 필요한 노드만 메모리를 할당하는 방식을 이용하기도 한다