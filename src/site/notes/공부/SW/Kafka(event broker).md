---
{"dg-publish":true,"permalink":"/공부/SW/Kafka(event broker)/","dgPassFrontmatter":true}
---

![Pasted image 20240123154610.jpg](/img/user/%EC%B2%A8%EB%B6%80%ED%8C%8C%EC%9D%BC/Pasted%20image%2020240123154610.jpg)

카프카는 RabbitMQ, ActiveMQ와 비교했을 때 ==높은 확장성과 내결함성, 대용량 데이터 처리, 실시간 데이터 처리에 특화되어 있는 오픈소스 메시징 시스템==이다.

### 특징
**메시지 순서 보장이 된다(채팅 기능에 가장 적합)**

높은 처리량과 낮은 지연시간으로 대용량 데이터를 실시간으로 처리할 수 있다

카프카의 메시지는 메모리가 아닌 디스크에 영구적으로 저장되기 때문에 장애 발생 시에도 메시지가 유실되지 않는다

카프카 클러스터 내부에 여러 대의 브로커 서버를 구성하여 높은 확장성과 내결함성을 갖는다

RabbitMQ와 ActiveMQ는 브로커가 컨슈머로 메시지를 Push 하는 방식인데 반해, 카프카는 컨슈머가 능동적으로 브로커로부터 메시지를 가져오는 Pull 방식이다

### 용어
- **카프카 클러스터 (kafka cluster)**: 하나 이상의 카프카 브로커들의 집합
- **브로커 (broker)**: 개별 카프카 서버. 브로커는 프로듀서로부터 메시지를 전달받아 토픽에 저장하고,컨슈머에 전달하는 역할을 한다. 브로커는 여러개의 토픽을 가질 수 있다.
- **토픽 (topic)**: 데이터가 저장되는 단위.
- **파티션 (partition)**: 확장성을 위해 토픽은 1개 이상의 파티션으로 나뉠 수 있다. 레코드에 키가 없다면 라운드 로빈으로 파티션에 나뉘어 저장되고, 같은 키를 가진 레코드는 같은 파티션에 저장된다.
- **오프셋 (offset)**: 파티션에 저장된 레코드는 증가하는 정수 ID를 갖고, 이를 오프셋이라고 부른다.
- **레코드 (record)**: 파티션에 저장되는 데이터
- **프로듀서 (producer)**: 카프카에 요청하여 토픽에 레코드를 추가하는 클라이언트. 카프카에 요청하는 애플리케이션이다.
- **컨슈머 (consumer)**: 하나 이상의 파티션과 토픽으로부터 ==레코드를 읽어오는 클라이언트==. 
- **컨슈머 그룹 (consumer group)**: 동일한 컨슈머 인스턴스를 여러개 생성하여 컨슈머 그룹을 구성할 수 있다. 